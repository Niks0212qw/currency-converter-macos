import SwiftUI
import Combine

// –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –≤–∞–ª—é—Ç–µ –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–Ω–æ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
struct SharedCurrencyRate: Codable {
    let code: String
    let name: String
    let rate: Double
    let flagEmoji: String
    let timestamp: Date
}

// –°–µ—Ä–≤–∏—Å –¥–ª—è –æ–±–º–µ–Ω–∞ –¥–∞–Ω–Ω—ã–º–∏ –º–µ–∂–¥—É –≥–ª–∞–≤–Ω—ã–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ–º –∏ –≤–∏–¥–∂–µ—Ç–æ–º
class CurrencyDataService {
    // –ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –≥—Ä—É–ø–ø—ã –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π, –¥–æ–ª–∂–µ–Ω —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–æ–≤–∞—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º –≤ Xcode
    static let appGroupIdentifier = "group.com.yourcompany.currencyconverter"
    
    // –ö–ª—é—á–∏ –¥–ª—è UserDefaults
    private enum UserDefaultsKeys {
        static let currencyRates = "currencyRates"
        static let lastUpdated = "lastUpdated"
    }
    
    // –ü–æ–ª—É—á–µ–Ω–∏–µ –æ–±—â–µ–≥–æ UserDefaults –¥–ª—è –≥—Ä—É–ø–ø—ã –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π
    static var sharedUserDefaults: UserDefaults? {
        return UserDefaults(suiteName: appGroupIdentifier)
    }
    
    // –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∫—É—Ä—Å–æ–≤ –≤–∞–ª—é—Ç (–≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –∏–∑ –æ—Å–Ω–æ–≤–Ω–æ–≥–æ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è)
    static func saveCurrencyRates(_ rates: [SharedCurrencyRate]) {
        guard let sharedDefaults = sharedUserDefaults else { return }
        
        do {
            let encoder = JSONEncoder()
            let data = try encoder.encode(rates)
            
            sharedDefaults.set(data, forKey: UserDefaultsKeys.currencyRates)
            sharedDefaults.set(Date(), forKey: UserDefaultsKeys.lastUpdated)
            sharedDefaults.synchronize()
        } catch {
            print("–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –∫—É—Ä—Å–æ–≤ –≤–∞–ª—é—Ç: \(error)")
        }
    }
    
    // –ü–æ–ª—É—á–µ–Ω–∏–µ –∫—É—Ä—Å–æ–≤ –≤–∞–ª—é—Ç (–≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –∏–∑ –≤–∏–¥–∂–µ—Ç–∞)
    static func getCurrencyRates() -> ([SharedCurrencyRate], Date) {
        guard let sharedDefaults = sharedUserDefaults else {
            return ([], Date())
        }
        
        // –ü–æ–ª—É—á–∞–µ–º –¥–∞—Ç—É –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
        let lastUpdated = sharedDefaults.object(forKey: UserDefaultsKeys.lastUpdated) as? Date ?? Date()
        
        // –ü–æ–ª—É—á–∞–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ –∫—É—Ä—Å—ã
        guard let data = sharedDefaults.data(forKey: UserDefaultsKeys.currencyRates) else {
            return ([], lastUpdated)
        }
        
        do {
            let decoder = JSONDecoder()
            let rates = try decoder.decode([SharedCurrencyRate].self, from: data)
            return (rates, lastUpdated)
        } catch {
            print("–û—à–∏–±–∫–∞ –ø—Ä–∏ —á—Ç–µ–Ω–∏–∏ –∫—É—Ä—Å–æ–≤ –≤–∞–ª—é—Ç: \(error)")
            return ([], lastUpdated)
        }
    }
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∞–∫—Ç—É–∞–ª—å–Ω–æ—Å—Ç–∏ –¥–∞–Ω–Ω—ã—Ö
    static func isDataFresh(within minutes: Int = 30) -> Bool {
        guard let sharedDefaults = sharedUserDefaults else { return false }
        
        guard let lastUpdated = sharedDefaults.object(forKey: UserDefaultsKeys.lastUpdated) as? Date else {
            return false
        }
        
        let calendar = Calendar.current
        let now = Date()
        let components = calendar.dateComponents([.minute], from: lastUpdated, to: now)
        
        guard let minutesElapsed = components.minute else { return false }
        return minutesElapsed < minutes
    }
}

// –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–ª—è –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è –æ—Ç–≤–µ—Ç–∞ API –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–æ–≥–æ –ë–∞–Ω–∫–∞ –†–æ—Å—Å–∏–∏
struct CBRResponse: Decodable {
    let Date: String
    let PreviousDate: String
    let PreviousURL: String
    let Timestamp: String
    let Valute: [String: CBRCurrency]
    
    struct CBRCurrency: Decodable {
        let ID: String
        let NumCode: String
        let CharCode: String
        let Nominal: Int
        let Name: String
        let Value: Double
        let Previous: Double
    }
}

// –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–ª—è –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è –æ—Ç–≤–µ—Ç–∞ ExchangeRate API
struct ExchangeRatesResponse: Codable {
    let result: String
    let base_code: String
    let time_last_update_unix: Int
    let rates: [String: Double]
}

struct Currency: Identifiable, Hashable {
    var id = UUID()
    var code: String
    var name: String
    var flagName: String
    
    // –í—ã—á–∏—Å–ª—è–µ–º–æ–µ —Å–≤–æ–π—Å—Ç–≤–æ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —ç–º–æ–¥–∑–∏-—Ñ–ª–∞–≥–∞
    var flagEmoji: String {
        switch code {
        case "RUB": return "üá∑üá∫"
        case "USD": return "üá∫üá∏"
        case "EUR": return "üá™üá∫"
        case "TRY": return "üáπüá∑"
        case "KZT": return "üá∞üáø"
        case "CNY": return "üá®üá≥"
        case "AED": return "üá¶üá™"
        case "UZS": return "üá∫üáø"
        case "BYN": return "üáßüáæ"
        case "THB": return "üáπüá≠"
        case "UAH": return "üá∫üá¶"
        case "GBP": return "üá¨üáß"
        case "JPY": return "üáØüáµ"
        default: return "üè≥Ô∏è"
        }
    }
}

// –ü–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ –¥–ª—è –æ–ø–µ—Ä–∞—Ü–∏–π –∫–∞–ª—å–∫—É–ª—è—Ç–æ—Ä–∞
enum CalculatorOperation {
    case none
    case add
    case subtract
    case multiply
    case divide
    case percent
    
    var symbol: String {
        switch self {
        case .none: return ""
        case .add: return "+"
        case .subtract: return "-"
        case .multiply: return "√ó"
        case .divide: return "√∑"
        case .percent: return "%"
        }
    }
}

class CurrencyCalculatorModel: ObservableObject {
    @Published var displayValue: String = "0"
    @Published var fromCurrency: Currency
    @Published var toCurrency: Currency
    @Published var calculationHistory: String = ""
    @Published var conversionRate: Double = 0.012
    @Published var lastUpdated: String = ""
    @Published var isLoading: Bool = false
    @Published var convertedValue: String = "0"
    @Published var showFromCurrencyPicker = false
    @Published var showToCurrencyPicker = false
    
    // –ù–æ–≤—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª–∞ –∫–∞–ª—å–∫—É–ª—è—Ç–æ—Ä–∞
    @Published var pendingOperation: CalculatorOperation = .none
    @Published var storedValue: Double = 0.0
    @Published var isPerformingOperation: Bool = false
    @Published var showCalculatorHistory: Bool = false
    @Published var calculatorHistory: String = ""
    
    // –°–ª–æ–≤–∞—Ä—å –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –∫—É—Ä—Å–æ–≤ –≤–∞–ª—é—Ç –∏–∑ –¶–ë –†–§
    @Published var cbrRates: [String: Double] = [:]
    // –°–ª–æ–≤–∞—Ä—å –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –∫—É—Ä—Å–æ–≤ –≤–∞–ª—é—Ç –∏–∑ ExchangeRate API
    @Published var exchangeRates: [String: Double] = [:]
    
    // –î–æ–±–∞–≤–ª—è–µ–º —Ç–∞–π–º–µ—Ä –¥–ª—è –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
    private var updateTimer: Timer?
    private let updateInterval: TimeInterval = 60 * 60 * 4.8 // –ü—Ä–∏–º–µ—Ä–Ω–æ 5 —Ä–∞–∑ –≤ –¥–µ–Ω—å (–∫–∞–∂–¥—ã–µ ~4.8 —á–∞—Å–∞)
    
    let availableCurrencies: [Currency] = [
        Currency(code: "RUB", name: "–†–æ—Å—Å–∏–π—Å–∫–∏–π —Ä—É–±–ª—å", flagName: "russia"),
        Currency(code: "USD", name: "–î–æ–ª–ª–∞—Ä –°–®–ê", flagName: "usa"),
        Currency(code: "EUR", name: "–ï–≤—Ä–æ", flagName: "europe"),
        Currency(code: "TRY", name: "–¢—É—Ä–µ—Ü–∫–∞—è –ª–∏—Ä–∞", flagName: "turkey"),
        Currency(code: "KZT", name: "–ö–∞–∑–∞—Ö—Å–∫–∏–π —Ç–µ–Ω–≥–µ", flagName: "kazakhstan"),
        Currency(code: "CNY", name: "–ö–∏—Ç–∞–π—Å–∫–∏–π —é–∞–Ω—å", flagName: "china"),
        Currency(code: "AED", name: "–î–∏—Ä—Ö–∞–º –û–ê–≠", flagName: "uae"),
        Currency(code: "UZS", name: "–£–∑–±–µ–∫—Å–∫–∏–π —Å—É–º", flagName: "uzbekistan"),
        Currency(code: "BYN", name: "–ë–µ–ª–æ—Ä—É—Å—Å–∫–∏–π —Ä—É–±–ª—å", flagName: "belarus"),
        Currency(code: "THB", name: "–¢–∞–∏–ª–∞–Ω–¥—Å–∫–∏–π –±–∞—Ç", flagName: "thailand"),
        Currency(code: "UAH", name: "–£–∫—Ä–∞–∏–Ω—Å–∫–∞—è –≥—Ä–∏–≤–Ω–∞", flagName: "ukraine"),
        Currency(code: "GBP", name: "–ë—Ä–∏—Ç–∞–Ω—Å–∫–∏–π —Ñ—É–Ω—Ç", flagName: "uk"),
        Currency(code: "JPY", name: "–Ø–ø–æ–Ω—Å–∫–∞—è –π–µ–Ω–∞", flagName: "japan")
    ]
    
    // –†–µ–∑–µ—Ä–≤–Ω—ã–µ –∫—É—Ä—Å—ã –Ω–∞ —Å–ª—É—á–∞–π –ø—Ä–æ–±–ª–µ–º —Å API
    private let backupRates: [String: Double] = [
        "USD": 1.0,
        "EUR": 0.92,
        "RUB": 85.49,
        "GBP": 0.78,
        "JPY": 149.8,
        "CNY": 7.18,
        "TRY": 32.5,
        "KZT": 450.2,
        "AED": 3.67,
        "UZS": 12450.0,
        "BYN": 3.25,
        "THB": 35.8,
        "UAH": 39.5
    ]
    
    init() {
        // –ò–∑–º–µ–Ω—è–µ–º –ø–æ—Ä—è–¥–æ–∫ –≤–∞–ª—é—Ç - –ø–µ—Ä–≤–æ–π –±—É–¥–µ—Ç USD, –≤—Ç–æ—Ä–æ–π RUB
        self.fromCurrency = availableCurrencies.first(where: { $0.code == "USD" }) ?? availableCurrencies[1]  // USD
        self.toCurrency = availableCurrencies.first(where: { $0.code == "RUB" }) ?? availableCurrencies[0]    // RUB
        
        // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ä–µ–∑–µ—Ä–≤–Ω—ã–µ –∫—É—Ä—Å—ã –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏
        self.exchangeRates = backupRates
        self.cbrRates = backupRates
        
        // –ó–∞–≥—Ä—É–∂–∞–µ–º –∞–∫—Ç—É–∞–ª—å–Ω—ã–µ –∫—É—Ä—Å—ã –∏–∑ –æ–±–æ–∏—Ö –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤
        fetchAllExchangeRates()
        
        // –ó–∞–ø—É—Å–∫–∞–µ–º –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ
        startPeriodicUpdates()
    }
    
    // –ú–µ—Ç–æ–¥ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
    func shouldUpdate() -> Bool {
        guard !lastUpdated.isEmpty else { return true }
        
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "dd.MM.yyyy, HH:mm"
        
        guard let lastUpdateDate = dateFormatter.date(from: lastUpdated) else {
            return true
        }
        
        // –ï—Å–ª–∏ –ø—Ä–æ—à–ª–æ –±–æ–ª–µ–µ 4 —á–∞—Å–æ–≤ —Å –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
        return Date().timeIntervalSince(lastUpdateDate) > 4 * 60 * 60
    }
    
    // –ú–µ—Ç–æ–¥ –¥–ª—è –∑–∞–ø—É—Å–∫–∞ –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏—Ö –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π
    func startPeriodicUpdates() {
        // –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π —Ç–∞–π–º–µ—Ä, –µ—Å–ª–∏ –µ—Å—Ç—å
        updateTimer?.invalidate()
        
        // –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π —Ç–∞–π–º–µ—Ä –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∫—É—Ä—Å–æ–≤
        updateTimer = Timer.scheduledTimer(
            withTimeInterval: updateInterval,
            repeats: true
        ) { [weak self] _ in
            self?.fetchAllExchangeRates()
        }
    }
    
    // –ú–µ—Ç–æ–¥ –¥–ª—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏—Ö –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π
    func stopPeriodicUpdates() {
        updateTimer?.invalidate()
        updateTimer = nil
    }
    
    // –ú–µ—Ç–æ–¥ –¥–ª—è —Å–±—Ä–æ—Å–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∑–∞–≥—Ä—É–∑–∫–∏ (–∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –ø—Ä–∏ –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏)
    func resetLoadingState() {
        isLoading = false
        print("–°–æ—Å—Ç–æ—è–Ω–∏–µ –∑–∞–≥—Ä—É–∑–∫–∏ –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ —Å–±—Ä–æ—à–µ–Ω–æ")
    }
    
    // –ì–ª–∞–≤–Ω—ã–π –º–µ—Ç–æ–¥ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∫—É—Ä—Å–æ–≤
    func fetchAllExchangeRates() {
        // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ —Å–±—Ä–∞—Å—ã–≤–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∑–∞–≥—Ä—É–∑–∫–∏
        isLoading = true
        print("–ù–∞—á–∏–Ω–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫—É—Ä—Å–æ–≤ –≤–∞–ª—é—Ç - \(Date())")
        
        // 1. –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–±—É–µ–º –æ–±–Ω–æ–≤–∏—Ç—å —á–µ—Ä–µ–∑ –¶–ë –†–§
        simpleFetchCBR { [weak self] success in
            guard let self = self else { return }
            
            if success {
                // –ï—Å–ª–∏ –¶–ë –†–§ —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω - –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ –æ–±–Ω–æ–≤–ª—è–µ–º –∏ ExchangeRate
                self.fetchExchangeRateOnly()
            } else {
                // –ï—Å–ª–∏ –¶–ë –†–§ –Ω–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å, –ø—Ä–æ–±—É–µ–º —Ç–æ–ª—å–∫–æ ExchangeRate
                self.fetchExchangeRateOnly()
            }
        }
        
        // –ì–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —á–µ—Ä–µ–∑ 15 —Å–µ–∫—É–Ω–¥
        DispatchQueue.main.asyncAfter(deadline: .now() + 15) {
            if self.isLoading {
                print("–ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ –≤—Å–µ–≥–æ –ø—Ä–æ—Ü–µ—Å—Å–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø–æ —Ç–∞–π–º–∞—É—Ç—É")
                self.isLoading = false
                self.updateLastUpdated(date: Date())
            }
        }
    }
    
    // –û–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π –º–µ—Ç–æ–¥ –¥–ª—è –∑–∞–ø—Ä–æ—Å–∞ –¥–∞–Ω–Ω—ã—Ö –¶–ë –†–§
    private func simpleFetchCBR(completion: @escaping (Bool) -> Void) {
        guard let url = URL(string: "https://www.cbr-xml-daily.ru/daily_json.js") else {
            completion(false)
            return
        }
        
        // –°–æ–∑–¥–∞–µ–º –∑–∞–ø—Ä–æ—Å —Å –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ–º –∫—ç—à–∞ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∞–∫—Ç—É–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
        let request = URLRequest(url: url,
                                 cachePolicy: .reloadIgnoringLocalAndRemoteCacheData,
                                 timeoutInterval: 7)
        
        URLSession.shared.dataTask(with: request) { [weak self] data, response, error in
            guard let self = self else {
                completion(false)
                return
            }
            
            guard let data = data, error == nil else {
                completion(false)
                return
            }
            
            do {
                // –ò—Å–ø–æ–ª—å–∑—É–µ–º JSONSerialization –¥–ª—è –±–æ–ª–µ–µ –Ω–∞–¥–µ–∂–Ω–æ–≥–æ –ø–∞—Ä—Å–∏–Ω–≥–∞
                if let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
                   let valute = json["Valute"] as? [String: [String: Any]] {
                    
                    var rates: [String: Double] = ["RUB": 1.0]
                    
                    // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≤–∞–ª—é—Ç—ã –∏–∑ –æ—Ç–≤–µ—Ç–∞ –¶–ë –†–§
                    for (code, currencyData) in valute {
                        if let value = currencyData["Value"] as? Double,
                           let nominal = currencyData["Nominal"] as? Int {
                            let rate = value / Double(nominal)
                            rates[code] = rate
                        }
                    }
                    
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –æ—Å–Ω–æ–≤–Ω—ã—Ö –≤–∞–ª—é—Ç
                    let requiredCodes = ["USD", "EUR", "GBP", "CNY"]
                    let hasEnoughData = requiredCodes.filter { rates[$0] != nil }.count >= 3
                    
                    DispatchQueue.main.async {
                        if hasEnoughData {
                            self.cbrRates = rates
                            completion(true)
                        } else {
                            print("–¶–ë –†–§ –≤–µ—Ä–Ω—É–ª –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –≤–∞–ª—é—Ç")
                            completion(false)
                        }
                    }
                } else {
                    completion(false)
                }
            } catch {
                print("–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ –¥–∞–Ω–Ω—ã—Ö –¶–ë –†–§: \(error)")
                completion(false)
            }
        }.resume()
        
        // –ì–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ —á–µ—Ä–µ–∑ 8 —Å–µ–∫—É–Ω–¥
        DispatchQueue.global().asyncAfter(deadline: .now() + 8) {
            completion(false)
        }
    }
    
    // –£–ø—Ä–æ—â–µ–Ω–Ω—ã–π –º–µ—Ç–æ–¥ –¥–ª—è –∑–∞–ø—Ä–æ—Å–∞ —Ç–æ–ª—å–∫–æ ExchangeRate —Å –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –≤—Å–µ—Ö –≤–∞–ª—é—Ç
    private func fetchExchangeRateOnly() {
        guard let url = URL(string: "https://open.er-api.com/v6/latest/USD") else {
            DispatchQueue.main.async {
                self.isLoading = false
            }
            return
        }
        
        // –°–æ–∑–¥–∞–µ–º –∑–∞–ø—Ä–æ—Å —Å –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ–º –∫—ç—à–∞ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∞–∫—Ç—É–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
        let request = URLRequest(url: url,
                                 cachePolicy: .reloadIgnoringLocalAndRemoteCacheData,
                                 timeoutInterval: 7)
        
        URLSession.shared.dataTask(with: request) { [weak self] data, response, error in
            guard let self = self else { return }
            
            // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≤ –≥–ª–∞–≤–Ω–æ–º –ø–æ—Ç–æ–∫–µ
            let finishUpdate = {
                DispatchQueue.main.async {
                    self.isLoading = false
                    self.updateLastUpdated(date: Date())
                }
            }
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –æ—à–∏–±–∫–∏
            guard let data = data, error == nil else {
                finishUpdate()
                return
            }
            
            do {
                // –ò—Å–ø–æ–ª—å–∑—É–µ–º JSONSerialization –¥–ª—è –±–æ–ª–µ–µ –Ω–∞–¥–µ–∂–Ω–æ–≥–æ –ø–∞—Ä—Å–∏–Ω–≥–∞
                if let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
                   let rates = json["rates"] as? [String: Double] {
                    
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —É –Ω–∞—Å –µ—Å—Ç—å –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ—Å–Ω–æ–≤–Ω—ã—Ö –≤–∞–ª—é—Ç
                    let requiredCodes = ["USD", "EUR", "RUB", "GBP", "JPY", "CNY", "TRY"]
                    let hasEnoughData = requiredCodes.filter { rates[$0] != nil }.count >= 3
                    
                    if hasEnoughData {
                        DispatchQueue.main.async {
                            // –ö–æ–ø–∏—Ä—É–µ–º –≤—Å–µ –∫—É—Ä—Å—ã –Ω–∞–ø—Ä—è–º—É—é
                            self.exchangeRates = rates
                            
                            // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –æ–±–Ω–æ–≤–ª—è–µ–º –¥–∞—Ç—É
                            self.updateLastUpdated(date: Date())
                            
                            // –û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –∏ —Å–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ
                            self.updateConversionRate()
                            self.saveRatesForWidget()
                            self.isLoading = false
                            
                            print("ExchangeRate –∫—É—Ä—Å—ã —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω—ã: \(rates.count) –≤–∞–ª—é—Ç")
                        }
                    } else {
                        print("ExchangeRate –≤–µ—Ä–Ω—É–ª –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö")
                        finishUpdate()
                    }
                } else {
                    print("–û—à–∏–±–∫–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã JSON –æ—Ç ExchangeRate API")
                    finishUpdate()
                }
            } catch {
                print("–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ –¥–∞–Ω–Ω—ã—Ö ExchangeRate: \(error)")
                finishUpdate()
            }
        }.resume()
        
        // –ì–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ —á–µ—Ä–µ–∑ 8 —Å–µ–∫—É–Ω–¥
        DispatchQueue.main.asyncAfter(deadline: .now() + 8) {
            if self.isLoading {
                print("–ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ –∑–∞–ø—Ä–æ—Å–∞ –∫ ExchangeRate –ø–æ —Ç–∞–π–º–∞—É—Ç—É")
                self.isLoading = false
                self.updateLastUpdated(date: Date())
            }
        }
    }
    
    // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –¥–∞—Ç—ã –∏–∑ –¶–ë–†
    private func parseDate(_ dateString: String) -> Date? {
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ssZ"
        return dateFormatter.date(from: dateString)
    }
    
    // –û–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π –º–µ—Ç–æ–¥ updateLastUpdated
    private func updateLastUpdated(date: Date? = nil) {
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "dd.MM.yyyy, HH:mm"
        
        // –í—Å–µ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–µ–∫—É—â—É—é –¥–∞—Ç—É –∏–ª–∏ –ø–µ—Ä–µ–¥–∞–Ω–Ω—É—é –¥–∞—Ç—É
        lastUpdated = dateFormatter.string(from: date ?? Date())
    }
    
    func updateConversionRate() {
        print("–û–±–Ω–æ–≤–ª—è–µ–º –∫–æ–Ω–≤–µ—Ä—Å–∏–æ–Ω–Ω—ã–π –∫—É—Ä—Å: \(fromCurrency.code) -> \(toCurrency.code)")
        
        // –û–ø—Ä–µ–¥–µ–ª—è–µ–º, –Ω—É–∂–Ω–æ –ª–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –¥–∞–Ω–Ω—ã–µ –¶–ë –†–§
        let useCBR = fromCurrency.code == "RUB" || toCurrency.code == "RUB"
        
        // –í—ã–±–∏—Ä–∞–µ–º –∏—Å—Ç–æ—á–Ω–∏–∫ –∫—É—Ä—Å–æ–≤
        let ratesSource = useCBR ? cbrRates : exchangeRates
        
        print("–ò—Å–ø–æ–ª—å–∑—É–µ–º –∏—Å—Ç–æ—á–Ω–∏–∫: \(useCBR ? "–¶–ë –†–§" : "ExchangeRate")")
        print("–î–æ—Å—Ç—É–ø–Ω—ã–µ –≤–∞–ª—é—Ç—ã –≤ –∏—Å—Ç–æ—á–Ω–∏–∫–µ: \(ratesSource.keys.joined(separator: ", "))")
        
        let fromRate = ratesSource[fromCurrency.code] ?? backupRates[fromCurrency.code] ?? 1.0
        let toRate = ratesSource[toCurrency.code] ?? backupRates[toCurrency.code] ?? 1.0
        
        print("–ö—É—Ä—Å –¥–ª—è \(fromCurrency.code): \(fromRate)")
        print("–ö—É—Ä—Å –¥–ª—è \(toCurrency.code): \(toRate)")

        if useCBR {
            if fromCurrency.code == "RUB" {
                conversionRate = 1.0 / toRate
                print("–†–∞—Å—á–µ—Ç RUB -> –∏–Ω–æ—Å—Ç—Ä–∞–Ω–Ω–∞—è: 1.0 / \(toRate) = \(conversionRate)")
            } else if toCurrency.code == "RUB" {
                conversionRate = fromRate
                print("–†–∞—Å—á–µ—Ç –∏–Ω–æ—Å—Ç—Ä–∞–Ω–Ω–∞—è -> RUB: \(fromRate)")
            } else {
                conversionRate = toRate / fromRate
                print("–†–∞—Å—á–µ—Ç —á–µ—Ä–µ–∑ RUB: \(toRate) / \(fromRate) = \(conversionRate)")
            }
        } else {
            conversionRate = toRate / fromRate
            print("–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π —Ä–∞—Å—á–µ—Ç: \(toRate) / \(fromRate) = \(conversionRate)")
        }
        
        let formatter = NumberFormatter()
        formatter.numberStyle = .decimal
        formatter.maximumFractionDigits = 4
        formatter.minimumFractionDigits = 4
        
        if let formatted = formatter.string(from: NSNumber(value: conversionRate)) {
            calculationHistory = "1 \(fromCurrency.code) = \(formatted) \(toCurrency.code)"
            print("–£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ –∏—Å—Ç–æ—Ä–∏—è —Ä–∞—Å—á–µ—Ç–∞: \(calculationHistory)")
        }
        
        convert()
    }
    
    // –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∫—É—Ä—Å–æ–≤ –≤–∞–ª—é—Ç –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∏–∑ –≤–∏–¥–∂–µ—Ç–∞
    private func saveRatesForWidget() {
        // –°–æ–∑–¥–∞–µ–º –º–∞—Å—Å–∏–≤ –∫—É—Ä—Å–æ–≤ –¥–ª—è —á–µ—Ç—ã—Ä–µ—Ö –≤–∞–ª—é—Ç
        var rates: [SharedCurrencyRate] = []
        
        // –ü–æ–ª—É—á–∞–µ–º –∫—É—Ä—Å—ã –∏–∑ –æ–±–æ–∏—Ö –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤
        let rateUSD = cbrRates["USD"] ?? exchangeRates["RUB"] ?? backupRates["RUB"] ?? 85.49
        
        // USD
        rates.append(SharedCurrencyRate(
            code: "USD",
            name: "–î–æ–ª–ª–∞—Ä –°–®–ê",
            rate: rateUSD,
            flagEmoji: "üá∫üá∏",
            timestamp: Date()
        ))
        
        // EUR
        let rateEUR = cbrRates["EUR"] ?? (exchangeRates["RUB"] ?? 85.49) / (exchangeRates["EUR"] ?? 0.92)
        rates.append(SharedCurrencyRate(
            code: "EUR",
            name: "–ï–≤—Ä–æ",
            rate: rateEUR,
            flagEmoji: "üá™üá∫",
            timestamp: Date()
        ))
        
        // TRY
        let rateTRY = cbrRates["TRY"] ?? (exchangeRates["RUB"] ?? 85.49) / (exchangeRates["TRY"] ?? 32.5)
        rates.append(SharedCurrencyRate(
            code: "TRY",
            name: "–¢—É—Ä–µ—Ü–∫–∞—è –ª–∏—Ä–∞",
            rate: rateTRY,
            flagEmoji: "üáπüá∑",
            timestamp: Date()
        ))
        
        // AED
        let rateAED = cbrRates["AED"] ?? (exchangeRates["RUB"] ?? 85.49) / (exchangeRates["AED"] ?? 3.67)
        rates.append(SharedCurrencyRate(
            code: "AED",
            name: "–î–∏—Ä—Ö–∞–º –û–ê–≠",
            rate: rateAED,
            flagEmoji: "üá¶üá™",
            timestamp: Date()
        ))
        
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∫—É—Ä—Å—ã –¥–ª—è –≤–∏–¥–∂–µ—Ç–∞
        CurrencyDataService.saveCurrencyRates(rates)
    }
    
    func swapCurrencies() {
        let temp = fromCurrency
        fromCurrency = toCurrency
        toCurrency = temp
        updateConversionRate()
    }
    
    // MARK: - –ú–µ—Ç–æ–¥—ã –∫–∞–ª—å–∫—É–ª—è—Ç–æ—Ä–∞
    
    func appendDigit(_ digit: String) {
        if isPerformingOperation {
            displayValue = digit
            isPerformingOperation = false
        } else if displayValue == "0" {
            displayValue = digit
        } else {
            displayValue += digit
        }
        convert()
    }
    
    func appendDecimal() {
        if isPerformingOperation {
            displayValue = "0."
            isPerformingOperation = false
        } else if !displayValue.contains(".") {
            displayValue += "."
        }
        convert()
    }
    
    func clear() {
        displayValue = "0"
        pendingOperation = .none
        storedValue = 0.0
        calculatorHistory = ""
        convert()
    }
    
    func deleteLastDigit() {
        if displayValue.count > 1 {
            displayValue.removeLast()
        } else {
            displayValue = "0"
        }
        convert()
    }
    
    func performOperation(_ operation: CalculatorOperation) {
        if let currentValue = Double(displayValue.replacingOccurrences(of: ",", with: ".")) {
            if operation == .percent {
                let percentResult = currentValue / 100.0
                displayValue = formatDisplayValue(percentResult)
                convert()
                return
            }
            
            if pendingOperation != .none {
                let result = calculateResult(storedValue, currentValue)
                displayValue = formatDisplayValue(result)
                storedValue = result
            } else {
                storedValue = currentValue
            }
            
            pendingOperation = operation
            isPerformingOperation = true
            calculatorHistory = "\(formatDisplayValue(storedValue)) \(operation.symbol)"
        }
        
        convert()
    }
    
    func performEquals() {
        if pendingOperation != .none {
            if let currentValue = Double(displayValue.replacingOccurrences(of: ",", with: ".")) {
                let result = calculateResult(storedValue, currentValue)
                calculatorHistory = "\(formatDisplayValue(storedValue)) \(pendingOperation.symbol) \(formatDisplayValue(currentValue)) = \(formatDisplayValue(result))"
                displayValue = formatDisplayValue(result)
                pendingOperation = .none
                isPerformingOperation = true
                convert()
            }
        }
    }
    
    private func calculateResult(_ firstValue: Double, _ secondValue: Double) -> Double {
        switch pendingOperation {
        case .add:
            return firstValue + secondValue
        case .subtract:
            return firstValue - secondValue
        case .multiply:
            return firstValue * secondValue
        case .divide:
            return secondValue != 0 ? firstValue / secondValue : 0
        case .percent:
            return firstValue * (secondValue / 100.0)
        case .none:
            return secondValue
        }
    }
    
    private func formatDisplayValue(_ value: Double) -> String {
        let formatter = NumberFormatter()
        formatter.numberStyle = .decimal
        formatter.maximumFractionDigits = 10
        
        if value.truncatingRemainder(dividingBy: 1) == 0 {
            formatter.maximumFractionDigits = 0
        }
        
        return formatter.string(from: NSNumber(value: value)) ?? "0"
    }
    
    func convert() {
        let formatter = NumberFormatter()
        formatter.numberStyle = .decimal
        
        if let number = formatter.number(from: displayValue) {
            let result = number.doubleValue * conversionRate
            formatter.maximumFractionDigits = 2
            if let formattedResult = formatter.string(from: NSNumber(value: result)) {
                convertedValue = formattedResult
            } else {
                convertedValue = "–û—à–∏–±–∫–∞"
            }
        } else {
            let cleanValue = displayValue
                .replacingOccurrences(of: " ", with: "")
                .replacingOccurrences(of: ",", with: ".")
            
            if let value = Double(cleanValue) {
                let result = value * conversionRate
                formatter.maximumFractionDigits = 2
                if let formattedResult = formatter.string(from: NSNumber(value: result)) {
                    convertedValue = formattedResult
                } else {
                    convertedValue = "–û—à–∏–±–∫–∞"
                }
            } else {
                convertedValue = "0"
            }
        }
    }
    
    func getRateForCurrency(_ currency: Currency) -> String {
        let ratesSource = currency.code == "RUB" ? cbrRates : exchangeRates
        
        guard let usdRate = exchangeRates["USD"],
              let currencyRate = ratesSource[currency.code] else {
            return "N/A"
        }
        
        let formatter = NumberFormatter()
        formatter.numberStyle = .decimal
        formatter.maximumFractionDigits = 4
        
        let rate = currencyRate / usdRate
        if let formattedRate = formatter.string(from: NSNumber(value: rate)) {
            return "1 USD = \(formattedRate) \(currency.code)"
        }
        
        return "N/A"
    }
}
